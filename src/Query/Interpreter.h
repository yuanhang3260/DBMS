#ifndef QUERY_INTERPRETER_H_
#define QUERY_INTERPRETER_H_

#include <map>
#include <memory>
#include <set>
#include <vector>

#include "Query/SqlQuery.h"
#include "Sql/parser.hh"
#include "Sql/scanner.hh"
#include "Storage/Record.h"

// autogenerated by Bison, don't panic
// if your IDE can't resolve it - call make first

namespace Query {

// This class is the interface for our scanner/lexer. The end user
// is expected to use this. It drives scanner/lexer. keeps
// parsed AST and generally is a good place to store additional
// context data. Both parser and lexer have access to it via internal 
// references.
class Interpreter {
 public:
  explicit Interpreter(DB::CatalogManager* catalog_m);

  // Parse SQL query, return 0 in success.
  bool Parse();
  bool Parse(const std::string& str);

  std::shared_ptr<SqlQuery> shared_query() { return query_; }

  // Switch scanner input stream. Default is standard input (std::cin).
  void SwitchInputStream(std::istream *is);

  bool debug() const { return debug_; }
  void set_debug(bool d) { debug_ = d; }
  void reset();

  std::string error_msg() const { return query_->error_msg(); }
  void set_error_msg(const std::string& msg) { query_->set_error_msg(msg); }

 private:
  // Used internally by Scanner YY_USER_ACTION to update location indicator
  void IncreaseLocation(unsigned int loc);

  // Used to get last Scanner location. Used in error messages.
  unsigned int location() const;

  Sql::Scanner m_scanner;
  Sql::Parser m_parser;
  unsigned int m_location;  // Used by scanner

  std::shared_ptr<SqlQuery> query_;

  bool debug_ = false;

  // This is needed so that Scanner and Parser can call some methods that we
  // want to keep hidden from the end user.
  friend class Sql::Parser;
  friend class Sql::Scanner;
};

}  // namespace Query

#endif  // QUERY_INTERPRETER_H_
